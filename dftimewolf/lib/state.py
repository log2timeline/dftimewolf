# -*- coding: utf-8 -*-
"""This class maintains the internal dfTimewolf state.

Use it to track errors, abort on global failures, clean up after modules, etc.
"""

from concurrent.futures import ThreadPoolExecutor, Future
import logging
import time
import threading
import traceback
from typing import TYPE_CHECKING, Callable, Dict, List, Optional, Sequence, Type, Any, TypeVar, Union  # pylint: disable=line-too-long

from dftimewolf.config import Config
from dftimewolf.lib import errors, utils
from dftimewolf.lib import telemetry
from dftimewolf.lib.containers import interface
from dftimewolf.lib.containers import manager as container_manager
from dftimewolf.lib.errors import DFTimewolfError
from dftimewolf.lib.modules import manager as modules_manager
from dftimewolf.lib.modules import module_runner
from dftimewolf.lib.module import ThreadAwareModule, BaseModule

if TYPE_CHECKING:
  from dftimewolf.lib import module as dftw_module

T = TypeVar("T", bound="interface.AttributeContainer")  # pylint: disable=invalid-name,line-too-long

logger = logging.getLogger('dftimewolf.state')

NEW_ISSUE_URL = 'https://github.com/log2timeline/dftimewolf/issues/new'

TELEMETRY = telemetry


class DFTimewolfState(object):
  """The main State class.

  Attributes:
    command_line_options (dict[str, Any]): Command line options passed to
        dftimewolf.
    config (dftimewolf.config.Config): Class to be used throughout execution.
    errors (list[tuple[str, bool]]): errors generated by a module. These
        should be cleaned up after each module run using the CleanUp() method.
    global_errors (list[tuple[str, bool]]): the CleanUp() method moves non
        critical errors to this attribute for later reporting.
    input (list[str]): data that the current module will use as input.
    output (list[str]): data that the current module generates.
    recipe: (dict[str, str]): recipe declaring modules to load.
    store (dict[str, object]): arbitrary data for modules.
    telemetry_store: store for statistics generated by modules.
  """

  def __init__(self, config: Type[Config], telemetry: telemetry.BaseTelemetry) -> None:
    """Initializes a state."""
    super(DFTimewolfState, self).__init__()
    self.command_line_options = {}  # type: Dict[str, Any]
    self._cache = {}  # type: Dict[str, str]
    #self._module_pool = {}  # type: Dict[str, BaseModule]
    self._state_lock = threading.Lock()
#    self._threading_event_per_module = {}  # type: Dict[str, threading.Event]
    self.config = config
    self.errors = []  # type: List[DFTimewolfError]
    self.global_errors = []  # type: List[DFTimewolfError]
    self.recipe = {}  # type: Dict[str, Any]
    self._container_manager = container_manager.ContainerManager(logger)
    self._abort_execution = False
    self.stdout_log = True
    self._progress_warning_shown = False
    self._telemetry = telemetry
  
    self._module_runner = module_runner.ModuleRunner(self, logger, self._telemetry)

  def LoadRecipe(
      self, recipe: Dict[str, Any], module_locations: Dict[str, str]) -> None:
    """Populates the internal module pool with modules declared in a recipe.

    Args:
      recipe (dict[str, Any]): recipe declaring modules to load.

    Raises:
      RecipeParseError: if a module in the recipe has not been declared.
    """
    self.recipe = recipe

    self._module_runner.LoadModules(recipe, module_locations)
    self._container_manager.ParseRecipe(recipe)

  def FormatExecutionPlan(self) -> str:
    """Formats execution plan.

    Returns information about loaded modules and their corresponding arguments
    to stdout.

    Returns:
      str: String representation of loaded modules and their parameters.
    """
    plan = ""
    maxlen = 0

    modules = self.recipe.get('preflights', []) + self.recipe.get('modules', [])

    for module in modules:
      if not module['args']:
        continue
      spacing = len(max(module['args'].keys(), key=len))
      maxlen = maxlen if maxlen > spacing else spacing

    for module in modules:
      runtime_name = module.get('runtime_name')
      if runtime_name:
        plan += '{0:s} ({1:s}):\n'.format(runtime_name, module['name'])
      else:
        plan += '{0:s}:\n'.format(module['name'])

      if not module['args']:
        plan += '  *No params*\n'
      for key, value in module['args'].items():
        plan += '  {0:s}{1:s}\n'.format(key.ljust(maxlen + 3), repr(value))

    return plan

  def LogExecutionPlan(self) -> None:
    """Logs the result of FormatExecutionPlan() using the base logger."""
    for line in self.FormatExecutionPlan().split('\n'):
      logger.debug(line)

  def AddToCache(self, name: str, value: Any) -> None:
    """Thread-safe method to add data to the state's cache.

    If the cached item is already in the cache it will be
    overwritten with the new value.

    Args:
      name (str): string with the name of the cache variable.
      value (object): the value that will be stored in the cache.
    """
    with self._state_lock:
      self._cache[name] = value

  def GetFromCache(self, name: str, default_value: Any = None) -> Any:
    """Thread-safe method to get data from the state's cache.

    Args:
      name (str): string with the name of the cache variable.
      default_value (object): the value that will be returned if
          the item does not exist in the cache. Optional argument
          and defaults to None.

    Returns:
      object: object from the cache that corresponds to the name, or
          the value of "default_value" if the cache does not contain
          the variable.
    """
    with self._state_lock:
      return self._cache.get(name, default_value)

  def StoreContainer(
      self,
      container: "interface.AttributeContainer",
      source_module: str,
      for_self_only: bool=False) -> None:
    """Thread-safe method to store data in the state's store.

    Args:
      container: data to store.
      source_module: the originating module.
      for_self_only: True if the container should only be available to the same
          module that stored it.
    """
    self._container_manager.StoreContainer(source_module=source_module,
                                           container=container,
                                           for_self_only=for_self_only)

  def LogTelemetry(
      self, telemetry_entry: telemetry.TelemetryCollection) -> None:
    """Method to store telemetry in the state's telemetry store.

    Args:
      telemetry_entry: The telemetry object to store.
    """
    for key, value in telemetry_entry.telemetry.items():
      if self._telemetry is not None:
        self._telemetry.LogTelemetry(
            key, value, telemetry_entry.module_name)

  def GetContainers(
      self,
      requesting_module: str,
      container_class: Type[T],
      pop: bool = False,
      metadata_filter_key: Optional[str] = None,
      metadata_filter_value: Optional[Any] = None) -> Sequence[T]:
    """Retrieve previously stored containers.

    Args:
      requesting_module: The name of the module making the retrieval.
      container_class (type): AttributeContainer class used to filter data.
      pop (Optional[bool]): Whether to remove the containers from the state when
          they are retrieved.
      metadata_filter_key (Optional[str]): Metadata key to filter on.
      metadata_filter_value (Optional[Any]): Metadata value to filter on.

    Returns:
      Collection[AttributeContainer]: attribute container objects provided in
          the store that correspond to the container type.

    Raises:
      RuntimeError: If only one metadata filter parameter is specified.
    """
    return self._container_manager.GetContainers(
        requesting_module=requesting_module,
        container_class=container_class,
        pop=pop,
        metadata_filter_key=metadata_filter_key,
        metadata_filter_value=metadata_filter_value)

  def RunAllModules(self, running_args: dict[str, Any]) -> None:
    """Runs the modules."""
    self._module_runner.Run(running_args)

  def RegisterStreamingCallback(
      self,
      module_name: str,
      callback: Callable[[interface.AttributeContainer], None],
      container_type: Type[T]) -> None:
    """Registers a callback for a type of container.

    The function to be registered should a single parameter of type
    interface.AttributeContainer.

    Args:
      module_name: The name of the module registering the callback
      callback: The method to be called.
      container_type: container type on which the callback will be called.
    """
    self._container_manager.RegisterStreamingCallback(
        module_name=module_name,
        callback=callback,
        container_type=container_type)

  def AddError(self, error: DFTimewolfError) -> None:
    """Adds an error to the state.

    Args:
      error (errors.DFTimewolfError): The dfTimewolf error to add.
    """
    if error.critical:
      self._abort_execution = True
    self.errors.append(error)

  def CleanUp(self) -> None:
    """Cleans up after running a module.

    The state's output becomes the input for the next stage. Any errors are
    moved to the global_errors attribute so that they can be reported at a
    later stage.
    """
    # Move any existing errors to global errors
    self.global_errors.extend(self.errors)
    self.errors = []

  def CheckErrors(self, is_global: bool = False) -> None:
    """Checks for errors and exits if any of them are critical.

    Args:
      is_global (Optional[bool]): True if the global_errors attribute should
          be checked. False if the error attribute should be checked.

    Raises:
      errors.CriticalError: If any critical errors were found.
    """
    error_objects = self.global_errors if is_global else self.errors
    critical_errors = False

    if error_objects:
      logger.error('dfTimewolf encountered one or more errors:')

    for index, error in enumerate(error_objects):
      logger.error(
          '{0:d}: error from {1:s}: {2:s}'.format(
              index + 1, error.name, error.message))
      if error.stacktrace:
        for line in error.stacktrace.split('\n'):
          logger.error(line)
      if error.critical:
        critical_errors = True

    if any(error.unexpected for error in error_objects):
      logger.critical('One or more unexpected errors occurred.')
      logger.critical(
          'Please consider opening an issue: {0:s}'.format(NEW_ISSUE_URL))

    if critical_errors:
      raise errors.CriticalError('Critical error found. Aborting.')

  def PublishMessage(
      self, source: str, message: str, is_error: bool = False) -> None:
    """Receives a message for publishing.

    The base class does nothing with this (as the method in module also logs the
    message). This method exists to be overridden for other UIs.

    Args:
      source: The source of the message.
      message: The message content.
      is_error: True if the message is an error message, False otherwise.
    """

  def ProgressUpdate(
      self, module_name: str, steps_taken: int, steps_expected: int) -> None:
    """Currently unsupported when no UI is in use."""
    if not self._progress_warning_shown:
      self._progress_warning_shown = True
      logger.debug('ProgressUpdate called in unsupported display mode.')

  def ThreadProgressUpdate(
      self, module_name: str, thread_id: str, steps_taken: int,
      steps_expected: int) -> None:
    """Currently unsupported when no UI is in use."""
    if not self._progress_warning_shown:
      self._progress_warning_shown = True
      logger.debug('ProgressUpdate called in unsupported display mode.')
