# -*- coding: utf-8 -*-
"""This class maintains the internal dfTimewolf state.

Use it to track errors, abort on global failures, clean up after modules, etc.
"""

import logging
import threading
from typing import TYPE_CHECKING, Callable, Dict, List, Optional, Sequence, Type, Any, TypeVar, Union  # pylint: disable=line-too-long

from dftimewolf.config import Config
from dftimewolf.lib import errors
from dftimewolf.lib import telemetry
from dftimewolf.lib.containers import interface
from dftimewolf.lib.containers import manager as container_manager
from dftimewolf.lib.errors import DFTimewolfError
from dftimewolf.lib.modules import module_runner

T = TypeVar("T", bound="interface.AttributeContainer")  # pylint: disable=invalid-name,line-too-long

logger = logging.getLogger('dftimewolf.state')

NEW_ISSUE_URL = 'https://github.com/log2timeline/dftimewolf/issues/new'

# TELEMETRY = telemetry


class DFTimewolfState(object):
  """The main State class.

  Attributes:
    command_line_options (dict[str, Any]): Command line options passed to
        dftimewolf.
    config (dftimewolf.config.Config): Class to be used throughout execution.
    errors (list[tuple[str, bool]]): errors generated by a module. These
        should be cleaned up after each module run using the CleanUp() method.
    global_errors (list[tuple[str, bool]]): the CleanUp() method moves non
        critical errors to this attribute for later reporting.
    input (list[str]): data that the current module will use as input.
    output (list[str]): data that the current module generates.
    recipe: (dict[str, str]): recipe declaring modules to load.
    store (dict[str, object]): arbitrary data for modules.
    telemetry_store: store for statistics generated by modules.
  """

  def __init__(self,
               config: Type[Config],
               telemetry: telemetry.BaseTelemetry) -> None:
    """Initializes a state."""
    super(DFTimewolfState, self).__init__()
    self.command_line_options = {}  # type: Dict[str, Any]
    self.config = config
    self.errors = []  # type: List[DFTimewolfError]
    self.global_errors = []  # type: List[DFTimewolfError]
    self.recipe = {}  # type: Dict[str, Any]
    self._abort_execution = False
    self.stdout_log = True
    self._progress_warning_shown = False
    self._telemetry = telemetry
  
    self._module_runner = module_runner.ModuleRunner(logger, self._telemetry, self.PublishMessage)

  def LoadRecipe(
      self, recipe: Dict[str, Any], module_locations: Dict[str, str]) -> None:
    """Populates the internal module pool with modules declared in a recipe.

    Args:
      recipe (dict[str, Any]): recipe declaring modules to load.

    Raises:
      RecipeParseError: if a module in the recipe has not been declared.
    """
    self.recipe = recipe

    self._module_runner.LoadModules(recipe, module_locations)

  def FormatExecutionPlan(self) -> str:
    """Formats execution plan.

    Returns information about loaded modules and their corresponding arguments
    to stdout.

    Returns:
      str: String representation of loaded modules and their parameters.
    """
    plan = ""
    maxlen = 0

    modules = self.recipe.get('preflights', []) + self.recipe.get('modules', [])

    for module in modules:
      if not module['args']:
        continue
      spacing = len(max(module['args'].keys(), key=len))
      maxlen = maxlen if maxlen > spacing else spacing

    for module in modules:
      runtime_name = module.get('runtime_name')
      if runtime_name:
        plan += '{0:s} ({1:s}):\n'.format(runtime_name, module['name'])
      else:
        plan += '{0:s}:\n'.format(module['name'])

      if not module['args']:
        plan += '  *No params*\n'
      for key, value in module['args'].items():
        plan += '  {0:s}{1:s}\n'.format(key.ljust(maxlen + 3), repr(value))

    return plan

  def LogExecutionPlan(self) -> None:
    """Logs the result of FormatExecutionPlan() using the base logger."""
    for line in self.FormatExecutionPlan().split('\n'):
      logger.debug(line)

  def RunAllModules(self, running_args: dict[str, Any]) -> None:
    """Runs the modules."""
    self._module_runner.Run(running_args)

  def AddError(self, error: DFTimewolfError) -> None:
    """Adds an error to the state.

    Args:
      error (errors.DFTimewolfError): The dfTimewolf error to add.
    """
    if error.critical:
      self._abort_execution = True
    self.errors.append(error)

  def CleanUp(self) -> None:
    """Cleans up after running a module.

    The state's output becomes the input for the next stage. Any errors are
    moved to the global_errors attribute so that they can be reported at a
    later stage.
    """
    # Move any existing errors to global errors
    self.global_errors.extend(self.errors)
    self.errors = []

  def CheckErrors(self, is_global: bool = False) -> None:
    """Checks for errors and exits if any of them are critical.

    Args:
      is_global (Optional[bool]): True if the global_errors attribute should
          be checked. False if the error attribute should be checked.

    Raises:
      errors.CriticalError: If any critical errors were found.
    """
    error_objects = self.global_errors if is_global else self.errors
    critical_errors = False

    if error_objects:
      logger.error('dfTimewolf encountered one or more errors:')

    for index, error in enumerate(error_objects):
      logger.error(
          '{0:d}: error from {1:s}: {2:s}'.format(
              index + 1, error.name, error.message))
      if error.stacktrace:
        for line in error.stacktrace.split('\n'):
          logger.error(line)
      if error.critical:
        critical_errors = True

    if any(error.unexpected for error in error_objects):
      logger.critical('One or more unexpected errors occurred.')
      logger.critical(
          'Please consider opening an issue: {0:s}'.format(NEW_ISSUE_URL))

    if critical_errors:
      raise errors.CriticalError('Critical error found. Aborting.')

  def PublishMessage(
      self, source: str, message: str, is_error: bool = False) -> None:
    """Receives a message for publishing.

    The base class does nothing with this (as the method in module also logs the
    message). This method exists to be overridden for other UIs.

    Args:
      source: The source of the message.
      message: The message content.
      is_error: True if the message is an error message, False otherwise.
    """

  def ProgressUpdate(
      self, module_name: str, steps_taken: int, steps_expected: int) -> None:
    """Currently unsupported when no UI is in use."""
    if not self._progress_warning_shown:
      self._progress_warning_shown = True
      logger.debug('ProgressUpdate called in unsupported display mode.')

  def ThreadProgressUpdate(
      self, module_name: str, thread_id: str, steps_taken: int,
      steps_expected: int) -> None:
    """Currently unsupported when no UI is in use."""
    if not self._progress_warning_shown:
      self._progress_warning_shown = True
      logger.debug('ProgressUpdate called in unsupported display mode.')
