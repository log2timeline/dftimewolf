# -*- coding: utf-8 -*-
"""Timesketch enhancer that exports Timesketch results."""

import json
import time

from dftimewolf.lib import module
from dftimewolf.lib import timesketch_utils
from dftimewolf.lib import utils
from dftimewolf.lib.containers import containers
from dftimewolf.lib.modules import manager as modules_manager


class TimesketchEnhancer(module.BaseModule):
  """Enhance Timesketch results with additional reports.

  input: A list of paths to plaso or CSV files.
  output: A URL to the generated timeline.

  Attributes:
    incident_id (str): Incident ID or reference. Used in sketch description.
    sketch_id (int): Sketch ID to add the resulting timeline to. If not
        provided, a new sketch is created.
    timesketch_api (TimesketchApiClient): Timesketch API client.
  """

  # The name of a ticket attribute that contains the URL to a sketch.
  _SKETCH_ATTRIBUTE_NAME = 'Timesketch URL'

  # Number of seconds the exporter sleeps between checking analyzer status.
  _ANALYZER_SECONDS_BETWEEN_CHECK = 3

  # Maximum number of wait cycles before bailing out waiting for analyzer runs.
  _ANALYZER_MAX_CHECKS = 20
  _ANALYZERS_COMPLETE_SET = frozenset(['ERROR', 'DONE'])

  # Name given to all report containers.
  _REPORT_NAME = 'TimesketchEnhancer'

  def __init__(self, state):
    super(TimesketchExporter, self).__init__(state)
    self.timesketch_api = None

  def SetUp(self,  # pylint: disable=arguments-differ
            timesketch_quick=False,
            views_to_skip='',
            aggregations_to_skip='',
            include_stories=False,
            token_password='',
            formatter='html'):
    """Sets up a Timesketch Enhancer module.

    Args:
      timesketch_quick (bool): If set to True then the enhancer will not wait
          until all analyzers are done running (and therefore skip adding
          reports).
      views_to_skip (str): A JSON formatted string with a list of View names
          that are not to be included when generating reports.
      aggregations_to_skip (str): A JSON formatted string with a list of
          Aggregation names that are not to be included when generating
          reports.
      include_stories (bool): If set to True then story content will be
          dumped into a report, otherwise stories will be ignored. Defaults
          to False.
      token_password (str): optional password used to decrypt the
          Timesketch credential storage. Defaults to an empty string since
          the upstream library expects a string value. An empty string means
          a password will be generated by the upstream library.
      formatter (str): optional string defining the formatting class that will
          be used for text formatting in reports. Valid options are:
          "html" or "markdown", defaults to "html".
    """
    self.timesketch_api = timesketch_utils.GetApiClient(
        self.state, token_password=token_password)
    if not self.timesketch_api:
      self.ModuleError(
          'Unable to get a Timesketch API client, try deleting the files '
          '~/.timesketchrc and ~/.timesketch.token', critical=True)

    if aggregations_to_skip:
      self._aggregations_to_skip = [
          str(x) for x in json.loads(aggregations_to_skip)]
    else:
      self._aggregations_to_skip = []

    if views_to_skip:
      self._views_to_skip = [str(x) for x in json.loads(views_to_skip)]
    else:
      self._views_to_skip = []

    if formatter.lower() == 'markdown':
      self._formatter = MarkdwownFormatter()
    else:
      self._formatter = HTMLFormatter()

    self._include_stories = include_stories

    # Check that we have a timesketch session.
    if not (self.timesketch_api or self.timesketch_api.session):
      message = 'Could not connect to Timesketch server'
      self.ModuleError(message, critical=True)

  def _GetSketchURL(self, sketch):
    """Returns a URL to access a sketch."""
    api_root = sketch.api.api_root
    ts_url, _, _ = api_root.partition('/api/v1')
    return '{0:s}/sketch/{1:d}/'.format(ts_url, sketch.id)

  def _GenerateAggregationString(self, sketch):
    """Returns a string with aggregation data.

    The function runs through all saved aggregations in a sketch
    and returns back a formatted string (using the formatter)
    with the results of teh run. Additionally all aggregation
    DataFrames are stored as containers, so that other modules
    can make use of them.

    Args:
      sketch (timesketch_api.sketch.Sketch): the sketch object.

    Returns:
        A formatted string with the results of aggregation runs
        on the sketch.
    """
    aggregation_strings = []
    for aggregation in sketch.list_aggregations(
        exclude_labels=['informational']):
      aggregation_strings.append(self._formatter.IndentText(
          '{0:s}: {1:s}'.format(aggregation.name, aggregation.description),
          level=2))

      if aggregation.name in self._aggregations_to_skip:
        continue

      data_frame = aggregation.table
      nr_rows, _ = data_frame.shape
      # Check whether a data frame is empty or not.
      if not nr_rows:
        continue

      data_frame.drop(['bucket_name'], axis=1, inplace=True)
      columns = list(data_frame.columns)
      # We are presenting aggregations here, which is a table that consists of
      # a column name and then the count. For easier reading in reports we want
      # the count to be the last column displayed.
      try:
        count_index = columns.index('count')
        count = columns.pop(count_index)
        columns.append(count)
      except ValueError:
        pass

      self.state.StoreContainer(containers.DataFrame(
          data_frame=data_frame[columns],
          description='Timesketch Aggregation: {0:s}'.format(
              aggregation.name), name=self._REPORT_NAME))

    return '\n'.join(aggregation_strings)

  def _GenerateStoryString(self, sketch):
    """Returns a string with story data.

    The function runs through all saved stories in a sketch and returns
    back a formatted string with an overview of all stored stories.
    In addition to that it adds a report container to the state object
    for each of the saved stories with the content of the story saved
    as a formatted text.

    Args:
      sketch (timesketch_api.sketch.Sketch): the sketch object.

    Returns:
        A formatted string with the results of all stories stored in
        the sketch.
    """
    story_strings = []
    sketch_url = self._GetSketchURL(sketch.id)
    for story in sketch.list_stories():
      story_url = '{0:s}story/{1:d}'.format(sketch_url, story.id)
      story_strings.append(self._formatter.IndentText(
          '[{0:s}]({1:s})'.format(story.title, story_url), level=2))

      if self._include_stories:
        self.state.StoreContainer(containers.Report(
            module_name='TimesketchExporter',
            text_format=self._formatter.FORMAT,
            text=story.to_markdown()))

    return '\n'.join(story_strings)

  def _GenerateViewString(self, sketch):
    """Returns a string with view data.

    The function runs through all saved views in a sketch and returns
    back a formatted string with the results of the run. In addition
    it adds a dataframe container to the state object with the resulting
    events from the view.

    Args:
      sketch (timesketch_api.sketch.Sketch): the sketch object.

    Returns:
        A formatted string with the results of aggregation runs
        on the sketch.
    """
    view_strings = []
    sketch_url = self._GetSketchURL(sketch)
    for view in sketch.list_views():
      if view.name in self._views_to_skip:
        continue

      # We only want to include automatically generated views from analyzers.
      if view.user != 'System':
        continue

      view_url = '{0:s}explore?view={1:d}'.format(sketch_url, view.id)
      view_strings.append(self._formatter.IndentText(
          '[{0:s}]({1:s})'.format(view.name, view_url), level=2))

      data_frame = sketch.explore(view=view, as_pandas=True)

      nr_rows, _ = data_frame.shape
      if not nr_rows:
        continue

      # Clean up the data frame, remove Timesketch specific columns.
      ts_columns = [x for x in data_frame.columns if x.startswith('_')]
      # Remove all columns from data frame which exist ts_columns list.
      data_frame.drop(ts_columns, axis=1, inplace=True)
      columns = list(data_frame.columns)

      # Move the datetime column to the first column displayed.
      try:
        index = columns.index('datetime')
        datetime = columns.pop(index)
        columns.insert(0, datetime)
      except ValueError:
        pass

      self.state.StoreContainer(
          containers.DataFrame(
              data_frame=data_frame[columns],
              name=self._REPORT_NAME,
              description='Timesketch View: {0:s} - {1:s}'.format(
                  view.name, view.description)))

    return '\n'.join(view_strings)

  def _WaitForAnalyzers(self, sketch):
    """Wait for all analyzers to complete their run.

    Args:
      sketch (timesketch_api.sketch.Sketch): the sketch object.
    """
    check_number = 0
    while True:
      if check_number >= self._ANALYZER_MAX_CHECKS:
        break

      status_set = set()
      # get_analyzer_status returns a dict with information about the run
      # or all analyzers in a given sketch. One of the information is the
      # current status of the analyzer run, ANALYZER_COMPLETE_SET contains
      # the status values of analyzers that have completed their work.
      for result in sketch.get_analyzer_status():
        status_set.add(result.get('status', 'N/A'))

      if status_set.issubset(self._ANALYZERS_COMPLETE_SET):
        break

      check_number += 1
      time.sleep(self._ANALYZER_SECONDS_BETWEEN_CHECK)

  def Process(self):
    """Executes a Timesketch enhancer module."""
    if self._timesketch_quick:
      self.logger.info('Not waiting for analyzers to run.')
      return

    if not self.timesketch_api:
      message = 'Could not connect to Timesketch server'
      self.ModuleError(message, critical=True)

    sketch = self.state.GetFromCache('timesketch_sketch')
    if not sketch:
      message = 'Missing the sketch, unable to connect to Timesketch.'
      self.ModuleError(message, critical=True)

    self.logger.info('Waiting for analyzers to complete their run.')

    summary_lines = [self._formatter.Heading('Timesketch Run', level=1)]
    summary_lines.append(self._formatter.Paragraph(
        'This is a summary of actions taken by Timesketch '
        'during its run.'))
    summary_lines.append(self._formatter.Paragraph(
        'To visit the sketch, click {0:s}'.format(self._formatter.Link(
            url=self._GetSketchURL(sketch), text='here'))))
    summary_lines.append(self._formatter.Paragraph(
        'Here is an overview of actions taken:'))

    self._WaitForAnalyzers(sketch)

    # Force a refresh of sketch data.
    _ = sketch.lazyload_data(refresh_cache=True)

    summary_lines.append(self._formatter.IndentStart())

    view_string = self._GenerateViewString(sketch)
    if view_string:
      summar_lines.append(self._formatter.IndentText(
          'The following views were discovered:\n'
          '{0:s}{1:s}{2:s}'.format(
              self._formatter.IndentStart(),
              view_string,
              self._formatter.IndentEnd())))
    else:
      summary_lines.append(self._formatter.IndentText(
          'No views were generated by analyzers.'))

    aggregation_string = self._GenerateAggregationString(sketch)
    if aggregation_string:
      summary_lines.append(self._formatter.IndentText(
          'Following aggregations were discovered:\n{0:s}{1:s}{2:s}'.format(
              self._formatter.IndentStart(),
              aggregation_string,
              self._formatter.IndentEnd())))

    else:
      summary_lines.append(self._formatter.IndentText(
          'No aggregations were generated by analyzers.'))

    story_string = self._GenerateStoryString(sketch)
    if story_string:
      summary_lines.append(self._formatter.IndentText(
          'The following stories were generated:\n{0:s}{1:s}{2:s}'.format(
              self._formatter.IndentStart(),
              story_string,
              self._formatter.IndentEnd())))
    else:
      summary_lines.append(self._formatter.IndentText(
          'No stories were generated by analyzers.'))

    summary_lines.append(self._formatter.IndentEnd())

    analyzer_results = sketch.get_analyzer_status(as_sessions=True)
    if analyzer_results:
      summary_lines.append(self._formatter.Line())
      summary_lines.append(self._formatter.Paragraph(
          'Information from analyzer run:'))
      summary_lines.append(self._formatter.IndentStart())

      completed_ids = set()
      for result in analyzer_results:
        if result.id in completed_ids:
          continue

        if result.log:
          log_text = self._formatter.IndentText(
              'Logs: {0:s}'.format(result.log), level=2)
        else:
          log_text = ''

        summary_lines.append(self._formatter.IndentText(
            'ID: {0:d}\n{1:s}{2:s}\n{3:s}{4:s}'.format(
                result.id,
                self._formatter.IndentStart(),
                '\n'.join([self._formatter.IndentText(
                    x.strip(), level=2) for x in result.results.split('\n')]),
                log_text,
                self._formatter.IndentEnd()
            )
        ))
        completed_ids.add(result.id)
      summary_lines.append(self._formatter.IndentEnd())

    report_attributes = [{'update_comment': True}]
    self.state.StoreContainer(containers.Report(
        module_name='TimesketchEnhancer', text_format='markdown',
        text='\n'.join(summary_lines), attributes=report_attributes))
    self.logger.info('Analyzer reports generated')


modules_manager.ModulesManager.RegisterModule(TimesketchEnhancer)
