"""A ContainerManager class."""


import threading
import typing
from typing import cast, Sequence, Type

from dftimewolf.lib.containers import interface


class ContainerManager():
  """A ConatinerManager.
  
  This ContainerManager handles container storage and delivery to modules.
  Modules can only receive containers from other modules that they directly
  depend on, according to the recipe (or themselves.) In this way, it implements
  a directional graph for container delivery.

  Attributes:
    _mutex: Practice safe container access.
    _dependencies: The module dependency mappings.
    _storage: Container storage.
  """

  def __init__(self):
    """Initialise a ContainerManager."""
    self._mutex = threading.Lock()
    self._dependencies: dict[str,  # Module name
                             list[str]  # Module names the module depends on
                            ] = None
    self._storage: dict[str,  # Module name
                        list[interface.AttributeContainer]  #  A list of containers generated by the module  # pylint: disable=line-too-long
                       ] = {}
#    self._storage: dict[str,  # Module name
#                        dict[str,  # Container type name
#                             list[interface.AttributeContainer]]  #  A list of containers generated by the module of the type  # pylint: disable=line-too-long
#                       ] = {}

  def ParseRecipe(self, recipe: dict[str, typing.Any]):
    """Parses a recipe to build the dependency graph."""
    self._dependencies = {}

    for module in recipe.get('preflights', []) + recipe.get('modules', []):
      name = module.get('runtime_name', module.get('name', None))
      if not name:
        raise RuntimeError("Name not set for module in recipe")

      self._dependencies[name] = module.get('wants', []) + [name]

  def StoreContainer(self,
                     source_module: str,
                     container: interface.AttributeContainer):
    """Adds a container to storage for later retrieval.

    Args:
      source_module: The module that generated the container.
      container: The container to store.
    """
    if not self._dependencies:
      raise RuntimeError("Container manager has not parsed a recipe yet")

    with self._mutex:
      if source_module not in self._storage:
#        self._storage[source_module] = {}
#      if container.CONTAINER_TYPE not in self._storage[source_module]:
#        self._storage[source_module][container.CONTAINER_TYPE] = []
#      self._storage[source_module][container.CONTAINER_TYPE].append(container)
        self._storage[source_module] = []
        self._storage[source_module].append(container)


  def GetContainers(self,
                    requesting_module: str,
                    container_class: Type[interface.AttributeContainer],
                    pop: bool = False,
                    metadata_filter_key: str | None = None,
                    metadata_filter_value: typing.Any = None
      ) -> Sequence[interface.AttributeContainer]:
    """Retrieves stored containers.
    
    A requesting module cannot retrieve containers that do not originate from a
    module that it depends on in the recipe or itself.
    
    Args:
      requesting_module: The module requesting the containers.
      container_class: The type of container to retrieve.
      pop: True to remove requested containers from storage.
      metadata_filter_key: An optional metadata key to use to filter.
      metadata_filter_value: An optional metadata value to use to filter.

    Returns:
      A sequence of containers that match the various filters.
    """
    if not self._dependencies:
      raise RuntimeError("Container manager has not parsed a recipe yet")
    if bool(metadata_filter_key) ^ bool(metadata_filter_value):
      raise RuntimeError('Must specify both key and value for attribute filter')

    with self._mutex:
      ret_val = []

      for dependency in self._dependencies[requesting_module]:
        containers = self._storage.get(dependency, [])  # All the containers generated by the dependency
        self._storage[dependency] = []  # Remove all containers

        for c in containers:
          if c.CONTAINER_TYPE != container_class.CONTAINER_TYPE:
            # Not the type we want - put it back
            self._storage[dependency].append(c)
            continue

          if (metadata_filter_key and
              c.metadata.get(metadata_filter_key) != metadata_filter_value):
            # Doesn't match metadat filter - put it back
            self._storage[dependency].append(c)
            continue

          # if we get this far, we want to deliver the container to the caller.
          ret_val.append(c)

          if not pop:
            # The caller wants it left in the state anyway - put it back.
            self._storage[dependency].append(c)

    return cast(Sequence[interface.AttributeContainer], ret_val)

#  def DedupeContainers(self,
#                       container_class: Type[interface.AttributeContainer]):
#    """Dedupe containers.
#    
#    Unsure if this is needed at the time of writing, but the functionality
#    exists in what this manager will replace.
#    """
#    if not self._dependencies:
#      raise RuntimeError("Container manager has not parsed a recipe yet")
#
#    raise NotImplementedError()
