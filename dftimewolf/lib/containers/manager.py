"""A ContainerManager class."""


import dataclasses
import logging
import threading
from typing import Any, cast, Sequence, Type, TypeVar

from dftimewolf.lib.containers import interface


T = TypeVar("T", bound="interface.AttributeContainer")  # pylint: disable=invalid-name,line-too-long


@dataclasses.dataclass
class _MODULE():
  """A helper class for tracking module storage and dependency info.

  Attributes:
    name:  The module name.
    dependencies: A list of modules that this module depends on.
    storage: A list of containers generated by the associated module.
    completed: True if the assiciated module has finished running.
  """
  name: str
  dependencies: list[str] = dataclasses.field(default_factory=list)
  storage: list[interface.AttributeContainer] = dataclasses.field(
      default_factory=list)
  completed: bool = False


class ContainerManager():
  """A ContainerManager.
  
  This ContainerManager handles container storage and delivery to modules.
  Modules can only receive containers from other modules that they directly
  depend on, according to the recipe (or themselves.) In this way, it implements
  a directional graph for container delivery.

  Attributes:
    _mutex: Practice safe container access.
    _modules: Container storage and dependency information.
  """

  def __init__(self, logger: logging.Logger) -> None:
    """Initialise a ContainerManager."""
    self._logger = logger
    self._mutex = threading.Lock()
    self._modules: dict[str, _MODULE] = {}

  def ParseRecipe(self, recipe: dict[str, Any]) -> None:
    """Parses a recipe to build the dependency graph.

    Args:
      recipe: The recipe dict, that comes from the recipe manager class.

    Raises:
      RuntimeError: If there is an error in the recipe definition.
    """
    with self._mutex:
      self._modules = {}

      for module in recipe.get('preflights', []) + recipe.get('modules', []):
        name = module.get('runtime_name', module.get('name', None))
        if not name:
          raise RuntimeError("Name not set for module in recipe")

        self._modules[name] = _MODULE(
            name=name, dependencies=module.get('wants', []) + [name])

  def StoreContainer(self,
                     source_module: str,
                     container: interface.AttributeContainer) -> None:
    """Adds a container to storage for later retrieval.

    Args:
      source_module: The module that generated the container.
      container: The container to store.

    Raises:
      RuntimeError: If the manager has not been configured with a recipe yet.
    """
    if not self._modules:
      raise RuntimeError("Container manager has not parsed a recipe yet")

    # If the container to add exists already in the state, don't add it again
    if container in self._modules[source_module].storage:
      return

    with self._mutex:
      self._logger.debug(
        f'{source_module} is storing a {container.CONTAINER_TYPE} '
        f'container: {str(container)}')
      self._modules[source_module].storage.append(container)

  def GetContainers(self,
                    requesting_module: str,
                    container_class: Type[T],
                    pop: bool = False,
                    metadata_filter_key: str | None = None,
                    metadata_filter_value: Any = None
      ) -> Sequence[T]:
    """Retrieves stored containers.
    
    A requesting module cannot retrieve containers that do not originate from a
    module that it depends on in the recipe or itself.
    
    Args:
      requesting_module: The module requesting the containers.
      container_class: The type of container to retrieve.
      pop: True if the returned containers should be removed from the state.
          False otherwise. Ignored if the source and requesting module do not
          match. That is, a module can only pop containers it has stored.
      metadata_filter_key: An optional metadata key to use to filter.
      metadata_filter_value: An optional metadata value to use to filter.

    Returns:
      A sequence of containers that match the various filters.

    Raises:
      RuntimeError: If the manager has not been configured with a recipe yet; or
          if only one of metadata_filter_(key|value) is specified.
    """
    if not self._modules:
      raise RuntimeError("Container manager has not parsed a recipe yet")
    if bool(metadata_filter_key) ^ bool(metadata_filter_value):
      raise RuntimeError('Must specify both key and value for attribute filter')

    with self._mutex:
      ret_val: list[tuple[interface.AttributeContainer, str]] = []

      for dependency in self._modules[requesting_module].dependencies:
        for c in self._modules[dependency].storage:
          if (c.CONTAINER_TYPE != container_class.CONTAINER_TYPE or
              (metadata_filter_key and
              c.metadata.get(metadata_filter_key) != metadata_filter_value)):
            continue
          ret_val.append((c, dependency))

      if pop:
        # A module can only pop containers it has stored.
        # Remove by unique object id: Not __eq__() in case there are dupes, or
        #   attempting to compare different types of containers.
        ids = [id(c) for c, _ in ret_val]
        self._modules[requesting_module].storage = [
            c for c in self._modules[requesting_module].storage
            if id(c) not in ids]

    self._logger.debug(
        f'{requesting_module} is retrieving {len(ret_val)} '
        f'{container_class.CONTAINER_TYPE} containers')
    for module, origin in ret_val:
      self._logger.debug(
          f'  * {str(module)} - origin: {origin}')

    return cast(Sequence[T], [c for c, _ in ret_val])

  def CompleteModule(self, module_name: str) -> None:
    """Mark a module as completed in storage.

    Containers can consume large amounts of memory. Marking a module as
    completed tells the container manager that containers no longer needed can
    be removed from storage to free up that memory.

    Args:
      module_name: The module that has completed running.

    Raises:
      RuntimeError: If the manager has not been configured with a recipe yet.
    """
    if not self._modules:
      raise RuntimeError("Container manager has not parsed a recipe yet")

    with self._mutex:
      self._modules[module_name].completed = True

      # With that `module_name` marked completed, any modules with all
      # dependants completed can have storage cleared.
      for name, module in self._modules.items():
        if self._CheckDependenciesCompletion(name):
          for c in module.storage:
            del c
          module.storage = []

  def _CheckDependenciesCompletion(self, module_name: str) -> bool:
    """For a module, checks if other modules that depend on are complete.

    Args:
      module_name: The module name to check for.

    Returns:
      True if all modules dependant on the named module have complete; False
          otherwise.
    """
    for _, module in self._modules.items():
      if module_name in module.dependencies:
        if not module.completed:
          return False
    return True
